<html>
	<head>
		<title>Your Tests Should Cover the Right Stuff -- Jon Canady (dot com)</title>
		<link rel="stylesheet" href="/stylesheets/style.css" type="text/css" />
		<link rel="stylesheet" href="/stylesheets/syntax.css" type="text/css" />
		<link rel="alternate" type="application/atom+xml" href="/atom.xml">
	</head>
	<body>
		<div id="header">
	<h1>Jon Canady</h1>
	<ul>
		<li><a href="/">About</a></li>
		<li><a href="/articles/">Bloggery</a></li>
		<li><a href="http://github.com/joncanady">Projects</a></li>
	</ul>
</div>
		<div id="content">
			<h1>Your Tests Should Cover the Right Stuff</h1>
			<h2>Feb 17, 2009</h2>
			
			
			
			<div id="alert">
				<p>This is an older post imported from my previous Wordpress blog. If you
				find any errors, <a href="mailto:jon@joncanady.com">let me 
				know</a>.</p>
			</div>
			
			
			
			<p>I'm not a big fan of test-driven development anyway, but when I hear people clamor for 100% code coverage through tests, I want to weep for my profession.</p>

<p>Look, TDD is fine when applied in the maintenance stage.  You're writing new tests to cover bugs found in production, that's good.  But during development, TDD slows you down unnecessarily.  Half of the time, features change half-way through development anyway, or they change once users start interacting with them.  Writing tests for not-yet-finalized features doesn't seem like a prudent use of time.  Similarly, writing tests so that 100% of our code is covered is <em>absolutely</em> a meaningless metric that just wasted a client's money.</p>

<p>Let me give you an example: <a href="http://innova-partners.com">the Company</a> develops a tool where you punch in bunch of drug names and we give you a yearly total of the price for those drugs.  It's awesome: uses a little AJAX to smoothly add drugs to a list, fetches a bunch of data from a data-store, has a core of ridiculously complex business logic – nothing too out of the ordinary here.</p>

<p>When I'm writing this app, though, why would I write tests that cover things like "I gave my Model id X, I'm expecting (1,2,3) to come back"?  Unless I'm writing my own database abstraction library, that's code that should <em>already work</em>, and that's out of scope for me anyway.</p>

<p>I'm an advocate of <em>Business-driven Tests</em>: locate the part of the app that's pure business logic.  If it's not all holed up in one or more modules/classes/whatevers then make that so.  Then write tests that cover every sweet buttery nook and cranny.  Because when a bug is reported in the application, your database library is probably not the culprit, and that mound of business logic that's unique to your application probably is.</p>


			<div>
				
				<span>
					<a rel="prev" href="/2009/02/17/thanks-linux/" 
					title="View Thanks Linux"
					>&larr; Previous: Thanks Linux</a>
				</span>
				
				<br />
				
				<span>
					<a rel="next" href="/2009/03/04/awesome-stuff-i-read/" 
					title="View Awesome Stuff I Read"
					>Next: Awesome Stuff I Read &rarr;</a>
				</span>
				
			</div> 

			<div id="footer">
	<p>Powered by <a href="http://github.com/mojombo/jekyll">Jekyll</a>; your visit consumed no database resources, and didn't need parsing. Isn't that awesome?</p>
	<p>Blog post text is covered by this <a rel="license" href="http://creativecommons.org/licenses/by-nc/3.0/us/">Creative Commons</a> license, everything else is mine.</p>
</div>

		</div>
	</body>
</html>